Возникает проблема, которую придется решить: мы не можем больше ожидать завершения выполнения сортировки левой части массива.
==================
==================
if (make_thread && (right_bound - left > 10000))
{
    auto f = async(launch::async, [&]()
                   { quicksort(array, left, right_bound); });
    quicksort(array, left_bound, right);
}
else
{
    quicksort(array, left, right_bound);
    quicksort(array, left_bound, right);
}
==================
==================
Здесь при вызове деструктора ~f поток, который вызвал async, блокируется, пока не завершится созданный им поток. Перепишем код, учитывая, что теперь у нас есть пул потоков:
==================
==================
if (make_thread && (right_bound - left > 10000))
{
    auto f = pool.push_task(quicksort, array, left, right_bound);
    quicksort(array, left_bound, right);
    f.wait();
}
else
{
    quicksort(array, left, right_bound);
    quicksort(array, left_bound, right);
}
==================
==================
Если мы напишем так, то поймаем deadlock или мертвую блокировку. Ведь получится, что каждый из потоков в пуле вызовет f.wait(), и ни один поток в итоге не будет выполняться, ожидая завершения задания другого, в то время как другой поток так же ждёт. Например, при всего двух потоках в пуле первый поток забросит подзадачу в пул, её подхватит второй поток, который простаивает, затем так же забросит подзадачу в пул. Но эту подзадачу некому обрабатывать, потоки зависли в ожидании. Получаем заклинивший пул.
Но нам нужно каким-то образом отследить момент окончания выполнения параллельной сортировки. Вам предстоит решить эту проблему самостоятельно.
Нужно придумать механизм, который переводил бы родительскую задачу в состояние готовности (фьючерс) тогда, когда все ее подзадачи были совершены.
Задачу можно решить, используя std::promise и std::shared_ptr, где последний поможет в качестве счетчика ссылок на родительскую задачу. За основу возьмите пул потоков из третьего юнита с концепцией work stealing.
Продемонстрируйте скорость работы алгоритма быстрой сортировки при использовании пула потоков. Учитывайте, что не стоит запускать задачу на вычисление левой части алгоритма в качестве подзадачи, если количество элементов в этой части не превосходит 100000 (расходы на захват мьютекса очень велики).